# 앱/클라이언트 보면 되는 브로커 서비스(9092)
apiVersion: v1
kind: Service
metadata:
  name: kafka
  namespace: rediclaim
spec:
  selector:
    app: kafka
  ports:
    - name: broker
      port: 9092
      targetPort: 9092
  type: ClusterIP

---

# KRaft 컨트롤러/브로커 내부 고정 DNS를 위한 Headless Service
apiVersion: v1
kind: Service
metadata:
  name: kafka-headless
  namespace: rediclaim
spec:
  clusterIP: None
  selector:
    app: kafka
  ports:
    - name: broker
      port: 9092
      targetPort: 9092
    - name: controller
      port: 9093
      targetPort: 9093

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kafka
  namespace: rediclaim
spec:
  serviceName: kafka-headless
  replicas: 1
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      enableServiceLinks: false   # KAFKA_PORT 자동 주입 X
      containers:
        - name: kafka
          image: confluentinc/cp-kafka:latest
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 9092
              name: broker
            - containerPort: 9093
              name: controller
          env:
            - name: TZ
              value: "Asia/Seoul"

            # --- KRaft 필수 ---
            - name: KAFKA_NODE_ID
              value: "1"
            - name: KAFKA_PROCESS_ROLES
              value: "broker,controller"

            # StatefulSet이라 kafka-0 고정 DNS 사용 가능
            - name: KAFKA_CONTROLLER_QUORUM_VOTERS
              value: "1@kafka-0.kafka-headless.rediclaim.svc.cluster.local:9093"
            - name: KAFKA_CONTROLLER_LISTENER_NAMES
              value: "CONTROLLER"

            # listeners: K8s 내부는 9092만 쓰면 됨 (HOST용 29092 같은 건 생략)
            - name: KAFKA_LISTENERS
              value: "PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093"
            - name: KAFKA_ADVERTISED_LISTENERS
              value: "PLAINTEXT://kafka.rediclaim.svc.cluster.local:9092"
            - name: KAFKA_LISTENER_SECURITY_PROTOCOL_MAP
              value: "PLAINTEXT:PLAINTEXT,CONTROLLER:PLAINTEXT"
            - name: KAFKA_INTER_BROKER_LISTENER_NAME
              value: "PLAINTEXT"

            # --- 단일 브로커 개발용 replication ---
            - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR
              value: "1"
            - name: KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
              value: "1"
            - name: KAFKA_TRANSACTION_STATE_LOG_MIN_ISR
              value: "1"
            - name: KAFKA_MIN_INSYNC_REPLICAS
              value: "1"
            - name: KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS
              value: "0"

            # --- KRaft 클러스터 ID / 로그 디렉토리 ---
            # compose에서 쓰던 CLUSTER_ID를 그대로 사용해도 됨 (형식 맞으면 OK)
            - name: CLUSTER_ID
              value: "ciWo7IWazngRchmPES6q5A=="
            - name: KAFKA_LOG_DIRS
              value: "/tmp/kraft-combined-logs"

          # kind 환경에서 Kafka가 메모리 압박으로 죽는 경우가 많아서 최소한 잡아두는 게 안전
          resources:
            requests:
              memory: "1Gi"
              cpu: "250m"
            limits:
              memory: "2Gi"
              cpu: "1000m"

          readinessProbe:
            tcpSocket:
              port: 9092
            initialDelaySeconds: 30
            periodSeconds: 10
          livenessProbe:
            tcpSocket:
              port: 9092
            initialDelaySeconds: 60
            periodSeconds: 10